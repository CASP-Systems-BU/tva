#ifndef TVA_B_SHARED_VECTOR_H
#define TVA_B_SHARED_VECTOR_H

#include "shared_vector.h"

#include <limits>
#include <cmath>

#include "../../debug/debug.h"

namespace tva {
    namespace operators {
        // Friend function
        template<typename T, typename V>
        void compare(const BSharedVector <T, V> &x_vec,
                                         const BSharedVector <T, V> &y_vec,
                                         BSharedVector <T, V> &eq,
                                         BSharedVector <T, V> &gt);

        template<typename T, typename V>
        void swap(BSharedVector <T, V> &x_vec,
                                      BSharedVector <T, V> &y_vec,
                                      BSharedVector <T, V> &bits);
    }


    /**
     * A SharedVector that contains boolean shares and supports secure boolean operations.
     * @tparam Share - Share data type.
     * @tparam EVector - Share container type.
     */
    template<typename Share, typename EVector>
    class BSharedVector : public SharedVector<Share, EVector> {

        /**
         * Used by bit_same() to shift elements (see Vector::bit_level_shift() for more details).
         * @param level_size - The shift level size in number of bits.
         * @return A new vector with all elements of `this` vector shifted according to the `level_size`.
         */
        BSharedVector bit_level_shift(const int &level_size) const {
            return BSharedVector(tva::service::runTime.execute_parallel(this->vector, &EVector::bit_level_shift, level_size));
            // return BSharedVector(this->vector.bit_level_shift(level_size));
        }

        BSharedVector reverse_bit_level_shift(const int &level_size) const {
            return BSharedVector(tva::service::runTime.execute_parallel(this->vector, &EVector::reverse_bit_level_shift, level_size));
            // return BSharedVector(this->vector.reverse_bit_level_shift(level_size));
        }

        /**
         * Creates a new shared vector that contains all elements of `this` vector right-shifted by `shift_size`.
         * @param shift_size - The number of bits to right-shift each element of `this` vector.
         * @return A new shared vector that contains the right-shifted elements.
         */
        BSharedVector bit_right_shift(const int &shift_size) const {
            return BSharedVector(tva::service::runTime.execute_parallel(this->vector, &EVector::bit_right_shift, shift_size));
            // return BSharedVector(this->vector.bit_right_shift(shift_size));
        }

        BSharedVector bit_left_shift(const int &shift_size) const {
            return BSharedVector(tva::service::runTime.execute_parallel(this->vector, &EVector::bit_left_shift, shift_size));
            // return BSharedVector(this->vector.bit_left_shift(shift_size));
        }


        /**
         * Creates a new shared vector whose i-th element is a single bit generated by XORing all bits of the i-th
         *  element of `this` vector, 0 <= i < size().
         * @return A new shared vector that contains single-bit elements generated as described above.
         */
        BSharedVector bit_xor() const {
            return BSharedVector(tva::service::runTime.execute_parallel(this->vector, &EVector::bit_xor));
            // return BSharedVector(this->vector.bit_xor());
        }

        // TODO (john): This must go through the runtime (and must a protocol primitive)
        /**
         * Masks each element in `this` vector by doing a bitwise logical AND with `n`.
         * @param n - The mask.
         */
        void mask(const Share& n) {
            tva::service::runTime.modify_parallel(this->vector, &EVector::mask, n);
            // this->vector.mask(n);
        }

        // TODO (john): This must go through the runtime (and must a protocol primitive)
        /**
         * Sets the bits of each element in `this` vector by doing a bitwise logical OR with `n`
         * @param n - The element that encodes the bits to set.
         */
        void set_bits(const Share& n) {
            tva::service::runTime.modify_parallel(this->vector, &EVector::set_bits, n);
            // this->vector.set_bits(n);
        }

        /**
         * Returns a new shared vector whose i-th element, let `e`, is constructed by comparing the i-th elements of the
         * two input vectors (`this` and `y`) as follows: if the i-th elements are the same up to their j-th bit (from
         * left to right), then the j-th bit of the element `e` is 1, otherwise it is 0.
         *
         * @param y - The vector that is compared with `this` vector.
         * @return A new shared vector with the same number of elements as `this` and `y` that is constructed as
         * explained above.
         *
         * NOTE: This method requires log(l) communication rounds, where l is the size of `Share` in bits.
         */
        BSharedVector bit_same(const BSharedVector &y) const {
            // NOTE: Rounding is needed because signed share types have one digit less.
            static const int MAX_BITS_NUMBER = std::pow(2, std::ceil(std::log2(std::numeric_limits<Share>::digits)));
            // Initialize vector
            BSharedVector sameBit (~((*this) ^ y));
            // For each round
            for (int level_size = 2; level_size <= MAX_BITS_NUMBER; level_size *= 2) {
                // TODO: use &= to void copying from intermediate vector to sameBit
                sameBit = sameBit.bit_level_shift(level_size) & sameBit;
            }
            return sameBit;
        }

    public:

        /**
         * Creates a BSharedVector of size `_size` and initializes it with zeros.
         * @param _size - The size of the BSharedVector.
         */
        explicit BSharedVector(const int& _size) : SharedVector<Share, EVector>(_size, Encoding::BShared) {}

        /**
         * This is a shallow copy constructor from EVector.
         * @param _shares - The EVector whose contents will be pointed by the BSharedVector.
         */
        explicit BSharedVector(EVector& _shares) : SharedVector<Share, EVector>(_shares, Encoding::BShared) {}

        /**
         * This is a move constructor from EVector.
         * @param _shares - The EVector whose contents will be moved to the new BSharedVector.
         */
        BSharedVector(EVector&& _shares) : SharedVector<Share, EVector>(_shares, Encoding::BShared) {}

        /**
         * This is a move constructor from another BSharedVector.
         * @param other - The BSharedVector whose contents will be moved to the new BSharedVector.
         */
        BSharedVector(BSharedVector&& other ) : SharedVector<Share, EVector>(other.vector, Encoding::BShared) {}

        /**
         * This is a copy constructor from another BSharedVector.
         * @param other - The BSharedVector whose contents will be copied to the new BSharedVector.
         */
        BSharedVector(const BSharedVector& other ) : SharedVector<Share, EVector>(other.vector, Encoding::BShared) {}

        /**
         * Copy constructor from a SharedVector.
         * @param _shares - The SharedVector object whose contents will be copied to the new BSharedVector.
         */
        explicit BSharedVector(SharedVector<Share, EVector> &_shares) : EncodedVector(_shares.encoding){
            assert(_shares.encoding==Encoding::BShared);
            auto secretShares_ = reinterpret_cast<BSharedVector *>(&_shares);
            this->vector = secretShares_->vector;
        }

        /**
         * Move constructor that creates a BSharedVector from a unique pointer to a SharedVector object.
         * @param base - The pointer to the SharedVector object whose contents will be moved to the new BSharedVector.
         */
        BSharedVector(std::unique_ptr<BSharedVector>&& base) : BSharedVector((BSharedVector*) base.get()){}

        /**
         * Shallow copy constructor that creates a BSharedVector from a unique pointer to a SharedVector object.
         * @param base - The SharedVector object whose contents will be pointed by the new BSharedVector.
         */
        BSharedVector(std::unique_ptr<BSharedVector>& base) : BSharedVector((BSharedVector*) base.get()){}

        /**
         * Move constructor that creates a BSharedVector from a pointer to another BSharedVector object.
         * @param _base - The BSharedVector that will be moved as a whole (contents + state) to the new BSharedVector.
         *
         * NOTE: This constructor is implicitly called by the two constructors above.
         */
        explicit BSharedVector(BSharedVector *_base) : BSharedVector(std::move(*_base)) {}

        /**
         * This is a deep move assignment. Applies the move assignment operator to EVector.
         * @param aSecretShares - The BSharedVector whose contents will be moved tot he current BSharedVector.
         * @return
         */
        BSharedVector& operator = (const BSharedVector && bSecretShares ) {
            this->encoding = bSecretShares.encoding;
            this->vector = bSecretShares.vector;
            return *this;
        }

        BSharedVector& operator = (const BSharedVector & bSecretShares ) {
            this->encoding = bSecretShares.encoding;
            this->vector = bSecretShares.vector;
            return *this;
        }

        /**
         * This is a deep move assignment from a unique pointer to a SharedVector object.
         * Applies the move assignment operator to EVector.
         * @param base - The pointer to the SharedVector object whose contents will be moved to the new BSharedVector.
         * @return A reference to this BSharedVector after modification.
         */
        BSharedVector& operator = (std::unique_ptr<BSharedVector>&& base ) {
            this->encoding = base.get()->encoding;
            this->vector = base.get()->vector;
            return *this;
        }

        /**
         * This is a copy assignment from a unique pointer to a SharedVector object.
         * Applies the copy assignment operator to EVector.
         * @param base - The SharedVector object whose contents will be copied to the new BSharedVector.
         * @return A reference to this BSharedVector after modification.
         */
        BSharedVector& operator = ( const std::unique_ptr<BSharedVector>& base ) {
            auto& _base = *base.get();
            this->encoding = _base.encoding;
            this->vector = _base.vector;
            return *this;
        }

//        // Assignment Copy Operator
//        BSecretShares& operator = (const BSecretShares & bSecretShares ) {
//            this->vector = std::move(bSecretShares);
//            return *this;
//        }
//        BSecretShares& operator = (std::unique_ptr<Shares>& base ) {
//            this->vector = std::move(base.get()[0]);
//            return *this;
//        }
        
        // Destructor
        virtual ~BSharedVector() {}

        /**
          * This is a conversion from ASharedVector to BSharedVector.
          */
        std::unique_ptr<ASharedVector < Share, EVector>> b2a_bit() {
            return std::unique_ptr<ASharedVector < Share, EVector>>
            (new ASharedVector<Share, EVector>(service::runTime.b2a_bit(this->vector)));
        }


        // **************************************** //
        //            Boolean operators             //
        // **************************************** //

        /**
         * Elementwise secure bitwise XOR.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of XOR.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise XORs.
         */
        binary_op(^, BSharedVector, xor_b, this, other);

        /**
         * Elementwise secure bitwise AND.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of AND.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise ANDs.
         */
        binary_op(&, BSharedVector, and_b, this, other);

        /**
         * Elementwise secure boolean completion.
         * This operator expects the input vector (`this`) to contain boolean shares.
         * @return A unique pointer to a new shared vector with all boolean shares of
         * `this` vector complemented.
         */
        unary_op(~, BSharedVector, not_b, this);

        /**
         * Elementwise secure boolean negation.
         * This operator expects the input vector (`this`) to contain boolean shares.
         * @return A unique pointer to a new shared vector with all boolean shares of
         * `this` vector negated.
         */
        unary_op(!, BSharedVector, not_b_1, this);

        /**
         * Elementwise secure less-than-zero comparison.
         * @return A unique pointer to a new shared vector that contains boolean shares of the elementwise
         * less-than-zero comparisons.
         */
        fn_no_input(ltz, BSharedVector, this);

        /**
         * Elementwise LSB extension.
         * This method creates a new vector whose i-th element has all its bits equal to the LSB of the i-th element of
         * `this` vector.
         * @return A unique pointer to a new shared vector that contains boolean shares of the elements
         * constructed as described above.
         */
        BSharedVector extend_lsb() const {
            return BSharedVector(tva::service::runTime.execute_parallel(this->vector, &EVector::extend_lsb));
            // return BSharedVector(this->vector.extend_lsb());
        }

        // // TODO: Refactor this functions
        // template<typename...T>
        // BSharedVector subset_reference(T... args) const {
        //     return BSharedVector(this->vector.subset_reference(args...));
        // }

        template<typename...T>
        BSharedVector simple_subset_reference(T... args) const {
            return BSharedVector(this->vector.simple_subset_reference(args...));
        }

        template<typename...T>
        BSharedVector alternating_subset_reference(T... args) const {
            return BSharedVector(this->vector.alternating_subset_reference(args...));
        }

        template<typename...T>
        BSharedVector reversed_alternating_subset_reference(T... args) const {
            return BSharedVector(this->vector.reversed_alternating_subset_reference(args...));
        }

        template<typename...T>
        BSharedVector repeated_subset_reference(T... args) const {
            return BSharedVector(this->vector.repeated_subset_reference(args...));
        }

        template<typename...T>
        BSharedVector cyclic_subset_reference(T... args) const {
            return BSharedVector(this->vector.cyclic_subset_reference(args...));
        }

        template<typename...T>
        BSharedVector directed_subset_reference(T... args) const {
            return BSharedVector(this->vector.directed_subset_reference(args...));
        }

        /**
         * Elementwise secure bitwise OR.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of OR.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise ORs.
         */
        std::unique_ptr<BSharedVector> operator|(const BSharedVector &other) const {
            // Logical OR is defined based on logical AND
            return ~(~(*this) & ~(other));
        }

        // **************************************** //
        //           Comparison operators           //
        // **************************************** //

        /**
         * Elementwise secure equality.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of equality.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise equality comparisons.
         */
        std::unique_ptr<BSharedVector> operator==(const BSharedVector &other) const {
            size_t size = this->size();
            assert(size == other.size());
            // Identify same-bits prefix
            BSharedVector same_bits = this->bit_same(other);
            // If the LSB is 1, it means that the respective elements from `this` and `other` are the same
            same_bits.mask((Share) 1);
            return std::unique_ptr<BSharedVector>(new BSharedVector(same_bits.vector));
        }

        /**
         * Elementwise secure inequality.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of inequality.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise inequality comparisons.
         */
        std::unique_ptr<BSharedVector> operator!=(const BSharedVector &other) const {
            return !((*this) == other);
        }

        /**
         * Elementwise secure greater-than comparison.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of greater-than.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise greater-than comparisons.
         */
        std::unique_ptr<BSharedVector> operator>(const BSharedVector &other) const {
            // TODO (john): Merge first round with "diagonal" computation to save one communication round
            assert(this->size() == other.size());
            // Number of bits in the share representation
            const int MAX_BITS_NUMBER = std::numeric_limits<Share>::digits;
            // Compute same-bits prefix
            BSharedVector sameBit = this->bit_same(other);
            BSharedVector shifted = sameBit.bit_right_shift(1);
            // Set the MSB of the same-bits prefix (needed for unsigned numbers)
            shifted.set_bits(((Share) 1) << (MAX_BITS_NUMBER - 1));
            // If MSBs are different, `this` is greater than `other` iff the MSB of `this` is set,
            // else if MSBs are the same and the second MSBs are not, then `this` is greater than `other`
            // iff the second MSB of `this` is set, else...
            BSharedVector xEdgeBit(sameBit.bit_right_shift(1) & (~sameBit) & (*this));
            // XOR bits to get the single-bit result
            BSharedVector res = xEdgeBit.bit_xor();
            // If the shares are signed numbers, we need to treat the sign bits differently
            if (std::is_signed<Share>::value) {
              // Extract sign bits
              BSharedVector sign_1 = this->bit_right_shift(MAX_BITS_NUMBER);
              BSharedVector sign_2 = other.bit_right_shift(MAX_BITS_NUMBER);
              // Are signs different?
              BSharedVector diffs = sign_1 ^ sign_2;
              // Update greater bits: `this` is greater than `other` iff the signs are different and `other` is
              // negative, otherwise keep the existing greater bits
              res = (diffs & sign_2) ^ (!diffs & res);
            }
            return std::unique_ptr<BSharedVector>(new BSharedVector(res.vector));
        }

        /**
         * Elementwise secure less-than comparison.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of less-than.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise less-than comparisons.
         */
        std::unique_ptr<BSharedVector> operator<(const BSharedVector &other) const {
            return other > (*this);
        }

        /**
         * Elementwise secure greater-or-equal comparison.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of greater-or-equal.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise greater-or-equal comparisons.
         */
        std::unique_ptr<BSharedVector> operator>=(const BSharedVector &other) const {
            return !((*this) < other);
        }

        /**
         * Elementwise secure less-or-equal comparison.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of less-or-equal.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise less-or-equal comparisons.
         */
        std::unique_ptr<BSharedVector> operator<=(const BSharedVector &other) const {
            return !((*this) > other);
        }

         /** 
         * Elementwise secure boolean addition.
         * This operator expects both input vectors (`this` and `other`) to have the same size.
         * @param other - The second operand of boolean addition.
         * @return A unique pointer to a new shared vector that contains boolean shares of
         * the elementwise additions.
         */
        std::unique_ptr<BSharedVector> operator+(const BSharedVector &other) const {
        #if USE_PARALLEL_PREFIX_ADDER
            return parallel_prefix_adder((*this), other);
        #else 
            return ripple_carry_adder((*this), other);
        #endif
        } 

        // TODO: support opening when we have a subset reference
        /**
         * Opens the vector to all computing parties.
         * @return The opened (plaintext) vector.
         */
        Vector<Share> open() const {
            return service::runTime.open_shares_b(this->vector);
        }

        // Friend function
        template <typename T, typename V>
        friend void tva::operators::compare(const BSharedVector<T, V>& x_vec,
                            const BSharedVector<T, V>& y_vec,
                            BSharedVector<T, V>& eq,
                            BSharedVector<T, V>& gt);

        template <typename T, typename V>
        friend void tva::operators::swap(BSharedVector<T, V> &x_vec,
                         BSharedVector<T, V> &y_vec,
                         BSharedVector<T, V> &bits);

        template <typename T, typename V> 
        friend std::unique_ptr<BSharedVector<T, V>> parallel_prefix_adder(
            const BSharedVector<T, V> &current, 
            const BSharedVector<T, V> &other);
        
        template <typename T, typename V> 
        friend std::unique_ptr<BSharedVector<T, V>> ripple_carry_adder(
            const BSharedVector<T, V> &current, 
            const BSharedVector<T, V> &other);

        template <typename T, typename V>
        friend std::pair<BSharedVector<T, V>, BSharedVector<T, V>> prefix_sum(
            const std::pair<BSharedVector<T, V>, BSharedVector<T, V>>& x,
            const std::pair<BSharedVector<T, V>, BSharedVector<T, V>>& y);
        
        // friend class
        template <typename T, typename V>
        friend class ASharedVector;

    };

    /**
    * Computes vectorized boolean addition using a parallel prefix adder.
    * @param current - the first BSharedVector  
    * @param other   - the second BSharedVector
    * @return A unique pointer to a new shared vector that contains boolean shares of 
    * the elementwise additions
    */
    template <typename Share, typename EVector>
    static std::unique_ptr<BSharedVector<Share, EVector>> parallel_prefix_adder(
            const BSharedVector<Share, EVector>& current, 
            const BSharedVector<Share, EVector>& other) {
        static const int MAX_BITS_NUMBER = std::pow(2, std::ceil(std::log2(std::numeric_limits<Share>::digits)));
        
        BSharedVector<Share, EVector> p = current ^ other;
        BSharedVector<Share, EVector> g = current & other;
        BSharedVector<Share, EVector> propagate(p.size());
        propagate = p;

        for(int i = 2; i <= MAX_BITS_NUMBER; i <<= 1) {
            BSharedVector<Share, EVector> g_shift = g.reverse_bit_level_shift(i);
            BSharedVector<Share, EVector> p_shift = p.reverse_bit_level_shift(i);
            std::pair<BSharedVector<Share, EVector>, BSharedVector<Share, EVector>> res = prefix_sum(std::make_pair(g, p),
                                                                                                     std::make_pair(g_shift, p_shift));
            g = res.first;
            p = res.second;
        }
        return std::unique_ptr<BSharedVector<Share, EVector>>(new BSharedVector<Share, EVector>(propagate ^ g.bit_left_shift(1)));
    } 

    /**
    * Computes vectorized boolean addition using a ripple carry adder.
    * @param current - the first BSharedVector  
    * @param other   - the second BSharedVector
    * @return A unique pointer to a new shared vector that contains boolean shares of 
    * the elementwise additions
    *
    * NOTE: can add bit compression and be modified to work with negatives and/or overflows
    */
    template <typename Share, typename EVector>
    static std::unique_ptr<BSharedVector<Share, EVector>> ripple_carry_adder(
            const BSharedVector<Share, EVector> &a,
            const BSharedVector<Share, EVector> &b) {
        static const int MAX_BITS_NUMBER = std::pow(2, std::ceil(std::log2(std::numeric_limits<Share>::digits)));

        int compressed_size = a.size() / MAX_BITS_NUMBER + (a.size() % MAX_BITS_NUMBER > 0);

        BSharedVector<Share, EVector> a_xor_b = a ^ b;
        BSharedVector<Share, EVector> a_and_b = a & b;

        BSharedVector<Share, EVector> carry_i(compressed_size);
        BSharedVector<Share, EVector> sum(a.size());

        for(int i = 0 ; i < MAX_BITS_NUMBER; ++i){
            BSharedVector<Share, EVector> a_xor_b_i = a_xor_b.vector.simple_bit_compress(i, 1, i, 1);
            BSharedVector<Share, EVector> a_and_b_i = a_and_b.vector.simple_bit_compress(i, 1, i, 1);

            BSharedVector<Share, EVector> sum_i = a_xor_b_i ^ carry_i;
            sum.vector.simple_bit_decompress(sum_i.vector, i, 1, i, 1);

            if (i < MAX_BITS_NUMBER - 1){
                carry_i = a_and_b_i | (carry_i & a_xor_b_i);
            }
        }

        return std::unique_ptr<BSharedVector<Share, EVector>>(new BSharedVector<Share, EVector>(sum));
    }

    /**
     * Computes a prefix graph component for the parallel prefix adder.
     * 
     * @tparam Share - Share data type
     * @tparam EVector - Share container type
     * @param x - A pair containing the non-shifted generate and propagate vectors of x 
     * @param y - A pair containing the shifted generate and propagate vectors of y
     * @return A new pair containing the output generate and propagate vectors
     *
     * NOTE: the first element in a pair is the generate vector and the second element is the propagate vector
     */
    template <typename Share, typename EVector>
    static std::pair<BSharedVector<Share, EVector>, BSharedVector<Share, EVector>> prefix_sum(
            const std::pair<BSharedVector<Share, EVector>, BSharedVector<Share, EVector>>& x,
            const std::pair<BSharedVector<Share, EVector>, BSharedVector<Share, EVector>>& y) {
        BSharedVector<Share, EVector> g_x = x.first;
        BSharedVector<Share, EVector> p_x = x.second;
        BSharedVector<Share, EVector> g_y = y.first;
        BSharedVector<Share, EVector> p_y = y.second;

        BSharedVector<Share, EVector> g_out = g_x | (p_x & g_y);
        BSharedVector<Share, EVector> p_out = p_x & p_y;
        return std::make_pair(g_out, p_out);
    }
}

#endif //TVA_B_SHARED_VECTOR_H
