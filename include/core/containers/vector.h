#ifndef TVA_VECTOR_H
#define TVA_VECTOR_H

#include <limits>
#include <memory>
#include <vector>

#include <iostream>
#include <algorithm>


#include <cmath>

#include "vector_data.h"

#define define_binary_vector_op(_op_);                                  \
inline Vector operator _op_ (const Vector &y) const {                   \
    int size = this->size();                                            \
    Vector res(size);                                                   \
    for(int i = 0; i < size; ++i){                                      \
        res[i] = (*this)[i] _op_ y[i];                                  \
    }                                                                   \
    return res;                                                         \
}                                                                       \

#define define_unary_vector_op(_op_);                                   \
inline Vector operator _op_ () const {                                  \
    int size = this->size();                                            \
    Vector res(size);                                                   \
    for(int i = 0; i < size; ++i){                                      \
        res[i] = _op_ (*this)[i];                                       \
    }                                                                   \
    return res;                                                         \
}                                                                       \


#define define_binary_vector_element_op(_op_);                          \
template <typename OtherType>                                           \
inline Vector operator _op_ (const OtherType & other) const {           \
    int size = this->size();                                            \
    Vector res(size);                                                   \
    for(int i = 0; i < size; ++i){                                      \
        res[i] = (*this)[i] _op_ other;                                 \
    }                                                                   \
    return res;                                                         \
}                                                                       \


namespace tva {

    // Forward declarations
    namespace service {
        class RunTime;
        template<typename InputType, typename ReturnType, typename ObjectType>
        class Task_1;
        template<typename InputType, typename ReturnType, typename ObjectType>
        class Task_2;
        template<typename InputType, typename ReturnType, typename...T>
        class Task_ARGS_RTR_1;
        template<typename InputType, typename ReturnType, typename...T>
        class Task_ARGS_RTR_2;
        template<typename InputType>
        class Task_ARGS_VOID_1;
        template<typename InputType>
        class Task_ARGS_VOID_2;
    }

    static inline int div_ceil(int x, int y) {
        return x / y + (x % y > 0);
    }

    /**
     * Extracts the bit at `bitIndex` from the given element.
     * @param share - The vector element whose bit we want to extract.
     * @param bitIndex - The zero-based index (0 is the LSB).
     * @return The extracted bit as a single-bit DataType element.
     */
    template<typename DataType>
    static inline DataType getBit(const DataType &share, const int &bitIndex) {
        using Unsigned_type = typename std::make_unsigned<DataType>::type;
        return ((Unsigned_type) share >> bitIndex) & (Unsigned_type) 1;
    }

    /**
     * Sets the bit at `bitIndex` in element `share` equal to the LSB of element `bit`.
     * @param share - The element whose bit we want to update.
     * @param bit - The element whose LSB must be copied into `share`.
     * @param bitIndex - The zero-based index (0 is the LSB) of the bit to be updated in element `share`.
     */
    template<typename DataType>
    static inline void setBit(DataType &share, const DataType &bit, const int &bitIndex) {
        using Unsigned_type = typename std::make_unsigned<DataType>::type;
        share = (share & ~(((Unsigned_type)1 << bitIndex))) | (bit << bitIndex);
    }

    /**
     * TVA's wrapper of std::vector<DataType> that provides vectorized plaintext operations.
     * @tparam DataType - The type of elements in the Vector (e.g., int, long, long long, etc.)
     */
    template<typename DataType>
    class Vector {
        using Unsigned_type = typename std::make_unsigned<DataType>::type;

        // The start index of the batch that is currently being processed
        int batch_start = 0;

        //  The end index of the batch that is currently being processed
        int batch_end = 0;

        /**
         * Creates a new Vector whose i-th element is generated by:
         * 1. splitting the bit representation of the i-th element of `this` Vector into parts of size `level_size`, and
         * 2. setting all bits of the least significant half of each part equal to the LSB of the most significant part.
         *
         * @param level_size - The number of bits (2^k, k>0) of each part within the bit representation of an element.
         * @return A new vector that contains elements generated as described above.
         *
         * NOTE: This method is used in secure greater-than and works relatively to the current batch.
         */
        inline Vector bit_level_shift(const int &level_size) const {
            // NOTE: Rounding is needed because signed data types have one digit less.
            static const int MAX_BITS_NUMBER = std::pow(2, std::ceil(std::log2(std::numeric_limits<DataType>::digits)));
            int size = this->size();
            Vector res(size);
            int half_level = level_size / 2;

            for (int i = 0; i < size; ++i) {
                res[i] = (*this)[i];
                for (int j = MAX_BITS_NUMBER - half_level; j > 0; j -= level_size) {
                    DataType bit = getBit((*this)[i], j);
                    for (int k = 1; k <= half_level; ++k) {
                        setBit(res[i], bit, j - k);
                    }
                }
            }
            return res;
        }

        /**
         * Creates a new Vector whose i-th element is generated by:
         * 1. splitting the bit representation of the i-th element of `this` Vector into parts of size `level_size`, and
         * 2. setting all bits of the most significant half of each part equal to the MSB of the least significant half.
         *
         * @param level_size - The number of bits (2^k, k>0) of each part within the bit representation of an element.
         * @return A new vector that contains elements generated as described above.
         *
         * NOTE: This method is bit_level_shift but from right to left, and is used in the parallel prefix adder for boolean addition.
         */

        inline Vector reverse_bit_level_shift(const int &level_size) const {
            // NOTE: Rounding is needed because signed data types have one digit less.
            static const int MAX_BITS_NUMBER = std::pow(2, std::ceil(std::log2(std::numeric_limits<DataType>::digits)));
            int size = this->size();
            Vector res(size);
            int half_level = level_size / 2;

            for (int i = 0; i < size; ++i) {
                res[i] = (*this)[i];
                for (int j = half_level - 1; j < MAX_BITS_NUMBER - half_level; j += level_size) {
                    DataType bit = getBit((*this)[i], j);
                    for (int k = 1; k <= half_level; ++k) {
                        setBit(res[i], bit, j + k);
                    }
                }
            }
            return res;
        }

        /**
         * Creates a new Vector that contains all elements of `this` Vector right-shifted by `shift_size`.
         * @param shift_size - The number of bits to right-shift each element of `this` Vector.
         * @return A new Vector that contains the right-shifted elements.
         *
         * NOTE: This method works relatively to the current batch.
         */
        inline Vector bit_right_shift(const int &shift_size) const {
            int size = this->size();
            Vector res(size);
            for (int i = 0; i < size; ++i) {
                res[i] = ((Unsigned_type) (*this)[i]) >> shift_size;
            }

            return res;
        }
        
        /**
         * Creates a new Vector that contains all elements of `this` Vector left-shifted by `shift_size`.
         * @param shift_size - The number of bits to left-shift each element of `this` Vector.
         * @return A new Vector that contains the left-shifted elements.
         *
         * NOTE: This method works relatively to the current batch.
         */

        inline Vector bit_left_shift(const int &shift_size) const {
            int size = this->size();
            Vector res(size);
            for (int i = 0; i < size; ++i) {
                res[i] = ((Unsigned_type) (*this)[i]) << shift_size;
            }

            return res;
        }

        /**
         * Creates a new Vector whose i-th element is a single bit generated by XORing all bits of the i-th element of
         * `this` Vector, 0 <= i < size().
         * @return A new Vector that contains single-bit elements generated as described above.
         *
         * NOTE: This method works relatively to the current batch.
         */
        inline Vector bit_xor() const {
            static const int MAX_BITS_NUMBER = std::numeric_limits<DataType>::digits;

            int size = this->size();
            Vector res(size);

            for (int i = 0; i < size; ++i) {
                res[i] = 0;
                for (int j = 0; j < MAX_BITS_NUMBER; ++j) {
                    res[i] ^= getBit((*this)[i], j);
                }
            }

            return res;
        }

        // TODO: check for a (different by one index) bug for `end`.
        /**
         * Returns a new vector containing elements in the range [start, end] that are `step` positions apart.
         * @param start - The index of the first element to be included in the output vector.
         * @param step - The distance between two consecutive elements.
         * @param end - The maximum possible index of the last element to be included in the output vector.
         * @return A new vector that contains the selected elements.
         *
         * NOTE: This method works relatively to the current batch.
         */
        Vector simple_subset(const int &start, const int &step, const int &end) const {
            int res_size = end - start + 1;

            auto res = Vector(res_size);

            for (int i = 0; i < res_size; i += step) {
                res.data[i / step] = (*this)[start + i];
            }
            return res;
        }

        /**
         * Sets the current batch equal to the whole vector.
         */
        void reset_batch() {
            batch_start = 0;
            batch_end = this->total_size();
        }

        // TODO: check the last index usage for consistency.
        /**
         * Sets start and end index of the current batch.
         * If the start index is negative, the start index is set to zero. If the end index is greater than the Vector's
         * size, the end index is set the max possible index.
         * @param _start_ind - The index of the first element in the current batch.
         * @param _end_ind - The index of the last element in the current batch.
         */
        void set_batch(const int &_start_ind, const int &_end_ind) {
            batch_start = (_start_ind >= 0) ? _start_ind : 0;
            batch_end = (_end_ind <= this->total_size()) ? _end_ind : this->total_size();
        }

        /**
         * @return The total number of elements in the vector.
         */
        inline int total_size() const {
            return this->data.get()->size();
        }

        // TODO: fix this using the VectorData Class
        /**
         * @return An iterator pointing to the first element.
         *
         * NOTE: This method is used by the communicator.
         */
        inline typename std::vector<DataType>::iterator begin() {
            return data.get()->begin() + batch_start;
        }

        // TODO: fix this using the VectorData Class
        /**
         * @return An iterator pointing to the last element.
         *
         * NOTE: This method is used by the communicator.
         */
        inline typename std::vector<DataType>::iterator end() {
            return data.get()->begin() + batch_end;
        }

    public:
//        /**
//         * This is the generic function in order create a new mapping for this vector.
//         * Note: that the function does not allocate a new memory location for data.
//         * Note: the mapping maps from the new index space to the original index space for data.
//         * In other words, composition will not work; new mapping pattern replaces the previous one.
//         * @param _subset_offset the index of the first element of the original vector to apply the pattern.
//         * @param _subset_step the index difference between the mapped to elements within each chunks.
//         * @param _subset_included_size the maximum size of each included chunk.
//         * @param _subset_excluded_size the maximum size of each excluded chunk.
//         * (included and excluded chunks alternate after offset).
//         * @param _subset_direction the direction of choosing elements (increasing index = 1) (decreasing index = -1).
//         * @param _subset_repetition number of times to repeat same mapped-to-elements after each other.
//         * @param _subset_cycles number of times concatenate the whole mapped-to-elements in the new reference.
//         * @return  Vector that points to the same memory location as the new one but different mapping for the indices.
//         */
//        Vector subset_reference(const int &_subset_offset,              // = 1
//                                const int &_subset_step,                // = 1
//                                const int &_subset_included_size,       // = -1
//                                const int &_subset_excluded_size,       // = -1
//                                const int &_subset_direction,           // = 1
//                                const int &_subset_repetition,          // = 1
//                                const int &_subset_cycles) const {      // = 1
//
//            Vector res = *this;  // Shallow copy constructor (res will point to the same memory as `this`)
//
//            // First set the variables that do not change
//            res.subset_offset = _subset_offset;
//            res.subset_step = _subset_step;
//            res.subset_direction = _subset_direction;
//            res.subset_repetition = _subset_repetition;
//            res.subset_cycles = _subset_cycles;
//
//
//            // Set Variables with default variables changeable
//            res.subset_included_size = _subset_included_size;
//            res.subset_excluded_size = _subset_excluded_size;
//
//            // Check if default variable should be modified
//            if (res.subset_included_size == -1) {
//                res.subset_included_size = this->total_size();
//            }
//
//            if (res.subset_excluded_size == -1) {
//                res.subset_excluded_size = this->total_size() - res.subset_included_size;
//            }
//
//            // Set the batch size
//            res.reset_batch();
//            return res;
//        }

        /**
         * Remaps the index space to choose a number of elements of the current vector.
         * Note: returned Vector points to the same memory location.
         * @param _subset_offset the index of the first element of the original vector to apply the pattern.
         * (default = 0)
         * @param _subset_step the index of the difference between each two included elements.
         * (default = 1)
         * @param _subset_included_size the size of the elements on which the pattern is applied.
         * (default = total_size())
         * @return Vector that has different index mapping to the original vector elements.
         */
        Vector simple_subset_reference(const int _start_index,
                                       const int _step,
                                       const int _end_index) const {
            Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                    new SimpleVectorData<DataType>(data, _start_index, _end_index, _step)
                    ));
            res.reset_batch();
            return res;
        }

        inline Vector simple_subset_reference(const int _start_index,
                                              const int _step) const {
            Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                    new SimpleVectorData<DataType>(data, _start_index, std::max(0, data.get()->size() - 1), _step)
            ));
            res.reset_batch();
            return res;
        }

        inline Vector simple_subset_reference(const int _start_index) const {
            Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                    new SimpleVectorData<DataType>(data, _start_index, std::max(0, data.get()->size() - 1), 1)
            ));
            res.reset_batch();
            return res;
        }

        /**
         * Applies an alternating pattern to include and exclude elements. It applies the pattern starting with
         * the element with `index = _subset_offset`. It then keeps alternating elements as included in the pattern of
         * or excluded from the pattern using the `_subset_included_size` and the `_subset_excluded_size` for each included
         * or excluded chunk.
         * @param _subset_offset the index of the first element to apply the pattern.
         * @param _subset_step the difference two each two included elements within the included the chunks.
         * @param _subset_included_size the size of a number of elements that we choosing from.
         * @param _subset_excluded_size the size of a number of elements that we are totally not choosing.
         * @return `Vector` that points to the same memory location as the original vector but with different index mapping.
         */
        Vector alternating_subset_reference(const int _subset_included_size,
                                            const int _subset_excluded_size) const {
            if (_subset_excluded_size != -1) {
                Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                        new AlternatingVectorData<DataType>(data, _subset_included_size, _subset_excluded_size)
                ));
                res.reset_batch();
                return res;
            } else {
                Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                        new AlternatingVectorData<DataType>(data, _subset_included_size,
                                                            this->total_size() - _subset_included_size)
                ));
                res.reset_batch();
                return res;
            }
        }

        Vector reversed_alternating_subset_reference(const int _subset_included_size,
                                                     const int _subset_excluded_size) const {
            if (_subset_excluded_size != -1) {
                Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                        new ReversedAlternatingVectorData<DataType>(data, _subset_included_size, _subset_excluded_size)
                ));
                res.reset_batch();
                return res;
            } else {
                Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                        new ReversedAlternatingVectorData<DataType>(data, _subset_included_size,
                                                                    this->total_size() - _subset_included_size)
                ));
                res.reset_batch();
                return res;
            }
        }

        /**
         * Applies a new indexing mapping to the current vector so that each element is repeated a number of times consecutively.
         * @param _subset_repetition the number of times each element is repeated.
         * @return `Vector` that points to the same memory location as the original vector but with different index mapping.
         */
        Vector repeated_subset_reference(const int _subset_repetition) const {
            Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                    new RepeatedVectorData<DataType>(data, _subset_repetition)
            ));
            res.reset_batch();
            return res;
        }

        /**
         * Applies a new indexing mapping such that after accessing the last element, we access the first element
         * again and keep accessing the elements in cycles.
         * @param _subset_cycles the number of cycles the new indexing mapping will contain.
         * @return `Vector` that points to the same memory location as the original vector but with different index mapping.
         */
        Vector cyclic_subset_reference(const int _subset_cycles) const {
            Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                    new CyclicVectorData<DataType>(data, _subset_cycles)
            ));
            res.reset_batch();
            return res;
        }

        /**
         * Applies a new mapping indexing that controls the order in which the elements accessed.
         * @param _subset_direction set to (1) to keep current order or (-1) to reverse the order.
         * @return `Vector` that points to the same memory location as the original vector but with different index mapping.
         */
        Vector directed_subset_reference(const int _subset_direction) const {
            if(_subset_direction == -1){
                Vector res(std::shared_ptr<VectorDataBase<DataType>>(
                        new ReversedVectorData<DataType>(data)
                ));
                res.reset_batch();
                return res;
            }else{
                return *this;
            }
        }

        /**
         * This function extracts bits from current vector and append them in sequence into
         * another vector. The functions chooses the bits by getting the needed parameters to
         * loop through the bits in each element.
         * @param start index of the first bit to be included (lowest significant).
         * @param step difference in index between each two consecutive bits.
         * @param end index of the last bit bit to be included (most significant)
         * @param repetition number of times each bit will be included.
         * @return a new `Vector` that has only the chosen bits in its elements (less size than input).
         */
        Vector simple_bit_compress(const int &start, const int &step, const int &end,
                                   const int &repetition) const {
            const int MAX_BITS_NUMBER = std::numeric_limits<Unsigned_type>::digits;

            const int bits_per_element = std::abs(((end - start + 1) / step) * repetition);
            const int total_bits = bits_per_element * this->size();
            const int total_new_elements = div_ceil(total_bits, MAX_BITS_NUMBER);

            Vector res(total_new_elements);

            for (int i = 0; i < total_bits; ++i) {
                setBit(res[i / MAX_BITS_NUMBER],
                       getBit((*this)[i / bits_per_element], start + (i % bits_per_element) / repetition * step),
                       i % MAX_BITS_NUMBER);
            }

            return res;
        }

        /**
         * Function to reverse the simple_bit_compress function. it takes an already
         * compressed `Vector` and assign from it the corresponding bits to the this called on
         * `Vector`.
         * @param other the vector that has the compressed bits.
         * @param start index of the first bit to be included (lowest significant).
         * @param step difference in index between each two consecutive bits.
         * @param end index of the last bit bit to be included (most significant)
         * @param repetition number of times each bit will be included.
         */
        void simple_bit_decompress(const Vector &other,
                                   const int &start, const int &step, const int &end,
                                   const int &repetition) {
            const int MAX_BITS_NUMBER = std::numeric_limits<Unsigned_type>::digits;

            const int bits_per_element = std::abs(((end - start + 1) / step) * repetition);
            const int total_bits = bits_per_element * this->size();
            const int total_new_elements = div_ceil(total_bits, MAX_BITS_NUMBER);

            for (int i = 0; i < total_bits; ++i) {
                setBit((*this)[i / bits_per_element],
                       getBit(other[i / MAX_BITS_NUMBER], i % MAX_BITS_NUMBER),
                       start + (i % bits_per_element) / repetition * step);
            }
        }


        /**
         * This function extracts bits from current vector and append them in sequence into
         * another vector. The function chooses bits as follows. First it skips till the start
         * index (from lowest significant). Then it splits the bits into sequences of included
         * chunks and excluded chunks. From the included bits chunks, bits that `step` index
         * difference apart are chosen. If direction is set to `1`, picking starts from lowest
         * significant bits. If it is set to `-1`, picking starts from most significant bits.
         * @param start index of the first bit to start the included/excluded chunks pattern.
         * @param step difference between each two consecutive bits in each included chunk.
         * @param included_size size of each included chunk.
         * @param excluded_size size of each excluded chunk.
         * @param direction direction for picking up the bits in each included_size chunk. `1` means
         * least significant first. `-1` means most significant first.
         * @return a new `Vector` that has only the chosen bits in its elements (less size than input).
         */
        Vector alternating_bit_compress(const int &start, const int &step,
                                        const int &included_size, const int &excluded_size,
                                        const int &direction) const {
            const int MAX_BITS_NUMBER = std::numeric_limits<Unsigned_type>::digits;

            const int bits_per_chunk = included_size / step;
            const int bits_per_element = (MAX_BITS_NUMBER - start) / (included_size + excluded_size) * bits_per_chunk;
            const int last_chunk_bits_per_element = std::min(included_size, ((MAX_BITS_NUMBER - start) % (included_size + excluded_size))) / step;
            const int total_bits_per_element = bits_per_element + last_chunk_bits_per_element;

            const int direction_offset = (direction == -1) ? included_size - 1: 0;

            const int total_bits = total_bits_per_element * this->size();
            const int total_new_elements = div_ceil(total_bits, MAX_BITS_NUMBER);

            Vector res(total_new_elements);

            for (int i = 0; i < total_bits; ++i) {
                const int element_index = i / total_bits_per_element;
                const int element_chunk_index = (i % total_bits_per_element) / bits_per_chunk;
                const int element_bit_index = start + direction_offset + element_chunk_index * (included_size + excluded_size) + ((i % total_bits_per_element) % bits_per_chunk) * step * direction;
                setBit(res[i / MAX_BITS_NUMBER],
                       getBit((*this)[element_index], element_bit_index),
                       i % MAX_BITS_NUMBER);
            }

            return res;
        }

        inline Vector alternating_bit_compress(const int &start, const int &step,
                                               const int &included_size, const int &excluded_size) const {
            return alternating_bit_compress(start, step, included_size, excluded_size, 1);
        }

        /**
         * Function to reverse the alternating_bit_compress function. it takes an already
         * compressed `Vector` and assign from it the corresponding bits to the this called on
         * `Vector`.
         * @param other the vector that has the compressed bits.
         * @param start index of the first bit to start the included/excluded chunks pattern.
         * @param step difference between each two consecutive bits in each included chunk.
         * @param included_size size of each included chunk.
         * @param excluded_size size of each excluded chunk.
         * @param direction direction for picking up the bits in each included_size chunk. `1` means
         * least significant first. `-1` means most significant first.
         */
        void alternating_bit_decompress(const Vector &other,
                                        const int &start, const int &step,
                                        const int &included_size, const int &excluded_size,
                                        const int &direction) const {
            const int MAX_BITS_NUMBER = std::numeric_limits<Unsigned_type>::digits;

            const int bits_per_chunk = included_size / step;
            const int bits_per_element = (MAX_BITS_NUMBER - start) / (included_size + excluded_size) * bits_per_chunk;
            const int last_chunk_bits_per_element = std::min(included_size, ((MAX_BITS_NUMBER - start) % (included_size + excluded_size))) / step;
            const int total_bits_per_element = bits_per_element + last_chunk_bits_per_element;

            const int direction_offset = (direction == -1) ? included_size - 1: 0;

            const int total_bits = total_bits_per_element * this->size();
            const int total_new_elements = div_ceil(total_bits, MAX_BITS_NUMBER);

            for (int i = 0; i < total_bits; ++i) {
                const int element_index = i / total_bits_per_element;
                const int element_chunk_index = (i % total_bits_per_element) / bits_per_chunk;
                const int element_bit_index = start + direction_offset + element_chunk_index * (included_size + excluded_size) + ((i % total_bits_per_element) % bits_per_chunk) * step * direction;
                setBit((*this)[element_index],
                       getBit(other[i / MAX_BITS_NUMBER], i % MAX_BITS_NUMBER),
                       element_bit_index);
            }
        }


        /**
         * A (shared) pointer to the actual vector contents.
         *
         * NOTE: Shallow copying of this object creates two instances that share the same data.
         */
        std::shared_ptr<VectorDataBase<DataType>> data;

//        /**
//         * This constructor allows for creating a new vector by just passing initialization
//         * parameters for inner `data` variable.
//         * @tparam T is a generic type to allow for different constructors for the variable `data`.
//         * @param args is the packed parameters passed to `data` initializer.
//         */
//        template<typename...T>
//        Vector(T... args) :
//                data(std::shared_ptr<std::vector<DataType>>(
//                        new std::vector<DataType>(args...))) { batch_end = data.get()->size(); }

        /**
         * Creates a Vector of `size` values initialize to `init_val` (0 by default).
         * @param size - The size of the new Vector.
         */
        Vector(size_t _size, DataType _init_val = 0) :
                data(std::shared_ptr<VectorDataBase<DataType>>(
                        new VectorData<DataType>(_size, _init_val))) {
            batch_end = data.get()->size();
        }

        // TODO: Should we use .size() or .total_size() here?
        /**
         * Move constructor
         * @param other - The std::vector<DataType> whose elements will be moved to the new Vector.
         */
        Vector(std::vector<DataType> &&_other) :
                data(std::shared_ptr<VectorDataBase<DataType>>(
                        new VectorData<DataType>(_other))),
                batch_end(_other.size()) {}

        /**
         * Copy constructor
         * @param other - The std::vector<DataType> whose elements will be copied to the new Vector.
         */
        Vector(std::vector<DataType> &_other) :
                data(std::shared_ptr<VectorDataBase<DataType>>(
                        new VectorData<DataType>(_other))),
                batch_end(_other.size()) {}

        /**
         * Constructs a new Vector from a list of `DataType` elements.
         * @param elements - The list of elements of the new Vector.
         */
        Vector(std::initializer_list<DataType> &&elements) :
                data(std::shared_ptr<VectorDataBase<DataType>>(
                        new VectorData<DataType>(elements))) {
            batch_end = data.get()->size();
        }

        /**
         * This is a shallow copy constructor.
         * @param other - The vector that contains the std::vector<DataType> pointer to be copied.
         *
         * WARNING: The new vector will point to the same memory location used by `other`. To copy the data into a
         * separate memory location, create a new vector first then use assignment operator.
         */
        Vector(const Vector &other) :
                data(other.data),
                batch_start(other.batch_start),
                batch_end(other.batch_end)
                {}

        Vector(std::shared_ptr<VectorDataBase<DataType>> other) :
                data(other),
                batch_start(0),
                batch_end(other->size()){}


        // TODO: move assignment has deleting guaranteed on the called-on variable
        //  Use this info to optimize assignment.
        /**
         * This is a deep move assignment operator.
         * Applies the move assignment operator to DataType. Assigns the contents of the `other` vector to the this
         * vector. Assumes `other` has the same size as this vector.
         * @param other - The Vector that contains the values to be assigned to this vector.
         * @return A reference to this vector after modification.
         *
         * NOTE: This method works relatively to the current batch.
         */
        Vector &operator=(const Vector &&other) {
            int size = this->size();
            for (int i = 0; i < size; ++i) {
                (*this)[i] = other[i];
            }
            return *this;
        }

        /**
         * This is a deep copy assignment operator.
         * Applies the copy assignment operator to DataType. Copies the contents of the `other` vector to this vector.
         * Assumes `other` has the same size as this vector.
         * @param other - the Vector that contains the values to be copied.
         * @return A reference to `this` Vector after modification.
         */
        Vector &operator=(const Vector &other) {
            int size = this->size();
            for (int i = 0; i < size; ++i) {
                (*this)[i] = other[i];
            }
            return *this;
        }

        /**
         * Returns a new vector that contains all elements in the range [start, end].
         * @param start - The index of the first element to be included in the output vector.
         * @param end - The index of the last element to be included in the output vector.
         * @return A new vector that contains the selected elements.
         *
         * NOTE: This method works relatively to the current batch.
         */
        Vector simple_subset(const int &start, const int &size) const {
            auto res = Vector(size);

            for (int i = 0; i < size; ++i) {
                res[i] = (*this)[start + i];
            }
            return res;
        }

        // Rename with `and` and refactor as a common macro
        /**
         * Masks each element in `this` vector by doing a bitwise logical AND with `n`.
         * @param n - The mask.
         */
        void mask(const DataType& n) {
            for (int i = 0; i < this->size(); ++i){
                (*this)[i] &= n;
            }
        }

        /**
         * Sets the bits of each element in `this` vector by doing a bitwise logical OR with `n`
         * @param n - The element that encodes the bits to set.
         */
        void set_bits(const DataType& n) {
            for (int i = 0; i < this->size(); ++i){
                (*this)[i] |= n;
            }
        }

        /**
         * @return The number of elements in the vector.
         *
         * NOTE: This method works relatively to the current batch.
         */
        inline int size() const {
//            printf("total_size: %d\n", this->total_size());
            return batch_end - batch_start;
        }

        // **************************************** //
        //           Arithmetic operators           //
        // **************************************** //

        /**
         * Elementwise plaintext addition.
         */
        define_binary_vector_op(+);

        /**
         * Elementwise plaintext subtraction.
         */
        define_binary_vector_op(-);

        /**
         * Elementwise plaintext multiplication.
         */
        define_binary_vector_op(*);

        /**
         * Elementwise plaintext negation.
         */
        define_unary_vector_op(-);

        // **************************************** //
        //             Boolean operators            //
        // **************************************** //

        /**
         * Elementwise plaintext bitwise AND.
         */
        define_binary_vector_op(&);

        /**
         * Elementwise plaintext bitwise OR.
         */
        define_binary_vector_op(|);

        /**
         * Elementwise plaintext bitwise XOR.
         */
        define_binary_vector_op(^);

        /**
         * Elementwise plaintext boolean complement.
         */
        define_unary_vector_op(~);

        /**
         * Elementwise plaintext boolean negation.
         */
        define_unary_vector_op(!);

        // **************************************** //
        //           Comparison operators           //
        // **************************************** //

        /**
         * Elementwise plaintext equality comparison.
         */
        define_binary_vector_op(==);

        /**
         * Elementwise plaintext inequality comparison.
         */
        define_binary_vector_op(!=);

        /**
         * Elementwise plaintext greater-than comparison.
         */
        define_binary_vector_op(>);

        /**
         * Elementwise plaintext greater-or-equal comparison.
         */
        define_binary_vector_op(>=);

        /**
         * Elementwise plaintext less-than comparison.
         */
        define_binary_vector_op(<);

        /**
         * Elementwise plaintext less-or-equal comparison.
         */
        define_binary_vector_op(<=);

        define_binary_vector_element_op(+);
        define_binary_vector_element_op(-);
        define_binary_vector_element_op(*);
        define_binary_vector_element_op(/);
        define_binary_vector_element_op(%);

        define_binary_vector_element_op(&);
        define_binary_vector_element_op(|);
        define_binary_vector_element_op(^);

        define_binary_vector_element_op(>>);
        define_binary_vector_element_op(<<);

        define_binary_vector_element_op(>);
        define_binary_vector_element_op(<);
        define_binary_vector_element_op(==);
        define_binary_vector_element_op(!=);

        // TODO: remove that; equivalent to `< 0`
        /**
         * Elementwise plaintext less-than-zero comparison.
         */
        inline Vector ltz() const {
            int size = this->size();
            Vector res(size);
            for (int i=0; i<size; i++)
                res[i] = ((*this)[i] < (DataType)0);
            return res;
        }

        // TODO: remove that; equivalent `* -1`
        // TODO: Does this work on bit shares only?
        /**
         * Elementwise plaintext LSB extension.
         */
        inline Vector extend_lsb() const {
            int size = this->size();
            Vector res(size);
            for (int i=0; i<size; i++)
                res[i] = -(*this)[i];  // Relies on two's complement
            return res;
        }

        /**
         * Returns a mutable reference to the element at the given `index`.
         * @param index - The index of the target element.
         * @return A mutable reference to the element at the given `index`.
         *
         * NOTE: This method works relatively to the current batch.
         */
        inline DataType &operator[](const int &index) {
            return (*data.get())[batch_start + index];
        }

        /**
         * Returns an immutable reference of the element at the given `index`.
         * @param index - The index of the target element.
         * @return Returns a read-only reference of the element at the given `index`.
         *
         * NOTE: This method works relatively to the current batch.
         */
        inline const DataType &operator[](const int &index) const {
            return (*data.get())[batch_start + index];
        }

//        /**
//         * Unpacks bits in the elements of `this` vector to create a new vector of size `n` whose i-th element equals
//         * the (i/n)-th bit of the (i%n)-th element of `this` vector.
//         * @param n - The number of bits to 'unpack'.
//         * @return A new Vector that contains `n` single-bit elements constructed as described above.
//         */
//        inline Vector bits2elements(int n) const {
//            static const int MAX_BITS_NUMBER = std::pow(2, std::ceil(std::log2(std::numeric_limits<DataType>::digits)));
//            Vector res(n);
//            int limit = ceil(n/this->size());
//            for (int i=0; i<limit; i++) {
//                for (int j=0; j<MAX_BITS_NUMBER; j++)
//                    res[i] = getBit(*this[i], j);
//            }
//            return res;
//        }

        // TODO: replace with aggregation functions
        //  - Functions that can sum together multiple elements `sum`
        //  - Functions that can do together multiple logical operations `and`, `or`, `xor`.
        /**
         * Checks if the two input vectors (`this` and `other`) contain the same elements.
         * @param other - The vector to compare `this` with.
         * @return True if `this` vector contains the same elements with `other`, False otherwise.
         */
        bool same_as(const Vector<DataType>& other) const {
            if (this->size() != other.size()) return false;
            for (int i=0; i<other.size(); i++)
                if ((*this)[i] != other[i]) return false;
            return true;
        }

        // Friend classes
        template <typename Share, int ReplicationNumber>
        friend class EVector;
        friend class service::RunTime;

        template<typename InputType, typename ReturnType, typename ObjectType>
        friend class tva::service::Task_1;

        template<typename InputType, typename ReturnType, typename ObjectType>
        friend class tva::service::Task_2;

        template<typename InputType, typename ReturnType, typename...T>
        friend class tva::service::Task_ARGS_RTR_1;

        template<typename InputType, typename ReturnType, typename...T>
        friend class tva::service::Task_ARGS_RTR_2;

        template<typename InputType>
        friend class tva::service::Task_ARGS_VOID_1;

        template<typename InputType>
        friend class tva::service::Task_ARGS_VOID_2;
    };

    /**
     * Same as BSharedVector::compare_rows() but works with plaintext data. Used for testing.
     *
     * Compares two `MxN` arrays row-wise by applying `M` greater-than comparisons on `N` keys.
     *
     * @tparam Share - Share data type.
     * @param x_vec - The left column-first array with `M` rows and `N` columns.
     * @param y_vec - The right column-first array with `M` rows and `N` columns.
     * @param inverse - A vector of `N` boolean values that denotes the order of comparison per key (if
     * `inverse[i]=True`, then rows from `x_vec` and `y_vec` are swapped in the comparison on the i-th column.
     * @return A new vector that contains the result bits of the `M` greater-than comparisons.
     *
     * NOTE: The i-th row, let l, from the left array is greater than the i-th row, let r, from the right array if l's
     * first key is greater than r's first key, or the first keys are the same and l's second key is greater than r's
     * second key, or the first two keys are the same and so forth, for all keys.
     */
     // TODO (john): Move this to utils
    template <typename Share>
    static Vector<Share> compare_rows(const std::vector<Vector<Share>*>& x_vec,
                                      const std::vector<Vector<Share>*>& y_vec,
                                      const std::vector<bool>& inverse) {
        assert((x_vec.size() > 0) && (x_vec.size() == y_vec.size()) && (inverse.size() == x_vec.size()));
        const int cols_num = x_vec.size();  // Number of keys
        // Compare elements on first key
        Vector<Share>* t = inverse[0] ? y_vec[0] : x_vec[0];
        Vector<Share>* o = inverse[0] ? x_vec[0] : y_vec[0];
        Vector<Share> eq = (*t == *o);
        Vector<Share> gt = (*t > *o);
        // Compare elements on remaining keys
        for (int i = 1; i < cols_num; ++i) {
            t = inverse[i] ? y_vec[i] : x_vec[i];
            o = inverse[i] ? x_vec[i] : y_vec[i];
            Vector<Share> new_eq = (*t == *o);
            Vector<Share> new_gt = (*t > *o);
            // Compose 'gt' and `eq` bits
            gt = gt ^ (new_gt & eq);
            eq = eq & new_eq;
        }
        return gt;
    }

    /**
     *
     * Same as BSharedVector::swap() but works with plaintext data. Used for testing.
     *
     * Swaps rows of two `MxN` arrays in place using the provided `bits`.
     *
     * @tparam Share - Share data type.
     * @param x_vec - The left column-first array with `M` rows and `N` columns.
     * @param y_vec - The right column-first array with `M` rows and `N` columns.
     * @param bits - The vector that contains the 'M' bits to use for swapping (if bits[i]=True, the i-th rows will be
     * swapped).
     */
    // TODO (john): Move this to utils
    template <typename Share>
    static void swap(std::vector<Vector<Share>*>& x_vec,
                     std::vector<Vector<Share>*>& y_vec,
                     const Vector<Share>& bits){
        // Make sure the input arrays have the same dimensions
        assert((x_vec.size() > 0) && (x_vec.size() == y_vec.size()));
        const int cols_num = x_vec.size();  // Number of columns
        for (int i = 0; i < cols_num; ++i) {
            assert((x_vec[i]->size() == y_vec[i]->size()) && (bits.size() == x_vec[i]->size()));
        }
        auto b = bits.extend_lsb();
        // Swap elements
        for (int i = 0; i < cols_num; ++i) {
            auto tmp = (b & *y_vec[i]) ^ (~b & *x_vec[i]);
            *y_vec[i] = (b & *x_vec[i]) ^ (~b & *y_vec[i]);
            *x_vec[i] = tmp;
        }
    }

    /**
     *
     * Same as BSharedVector::swap() but works with plaintext data. Used for testing.
     *
     * Swaps rows of two `MxN` arrays in place using the provided `bits`.
     *
     * @tparam Share - Share data type.
     * @param x_vec - The left column-first array with `M` rows and `N` columns.
     * @param y_vec - The right column-first array with `M` rows and `N` columns.
     * @param bits - The vector that contains the 'M' bits to use for swapping (if bits[i]=True, the i-th rows will be
     * swapped).
     */
    // TODO (john): Move this to utils
    template <typename Share>
    static void swap(Vector<Share>& x_vec,
                     Vector<Share>& y_vec,
                     const Vector<Share>& bits){
        // Make sure the input arrays have the same dimensions
        assert((x_vec.size() > 0) && (x_vec.size() == y_vec.size()) && (bits.size() == x_vec.size()));
        auto b = bits.extend_lsb();
        // Swap elements
        auto tmp = (b & y_vec) ^ (~b & x_vec);
        y_vec = (b & x_vec) ^ (~b & y_vec);
        x_vec = tmp;
    }

} // namespace tva

#endif // TVA_VECTOR_H
